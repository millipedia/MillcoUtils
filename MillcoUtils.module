<?php

namespace ProcessWire;

use function PHPSTORM_META\map;

/**
 * MillcoUtils
 * 
 * Just a collection of things we like to have in a site.
 */


class MillcoUtils extends Process implements Module, ConfigurableModule
{

	public $mu_nonce;// a page nonce we set for use in inline scripts etc
	public $mu_settings; // some sitewide settings.

	const ajax_noaccess = "ajax-noaccess";
	const ajax_rendererror = "ajax-render-error";

	public static function getModuleInfo()
	{
		return [
			'title' => 'MillcoUtils',
			'summary' => 'Very simple config options we often use.',
			'version' => 1,
			'autoload' => true,
			'singular' => true,
			'permanent' => false,

			'permission' => 'millco-utils',
			'permissions' => array(
				'millco-utils' => 'Millco Utils',
				'millco-utils-manage' => 'Manage Millco Utils',
				'millco-utils-editbutton' => 'Show edit button'
			),

			'icon' => 'cogs',
			// page that you want created to execute this module
			'page' => [
				'name' => 'mu',
				'parent' => 'setup',
				'title' => 'Utils',
				'permission' => 'millco-utils-manage',
			],
			// Me trying and failing to add permissions to the 
			// page created under setup
			// 'useNavJSON' => true, 
			// 'nav' => [
			// 	[
			// 	  'url' => '', 
			// 	  'label' => __('Utils'),
			// 	  'permission' => 'millco-utils-manage',
			// 	],
			// ],
			'requires' => [
				'PHP>=8.0.0',
				'ProcessWire>=3.0.16',
			],
		];
	}

	// Add config fields.
	function getModuleConfigInputfields(InputfieldWrapper $inputfields)
	{
		// actually do I want to do these here we have them on the page?
		return $inputfields;
	}

	static protected $defaults = array(
		'top' => '',
		'right' => '',
		'bottom' => '',
		'left' => '',
		'twitter' => '',
		'youtube' => '',
		'facebook' => '',
		'instagram' => '',
		'extra_buttons' => ''
	);

	public function __construct()
	{
		// populate defaults, which will get replaced with actual
		// configured values before the init/ready methods are called
		$this->setArray(self::$defaults);
	}



	// 	init() method: This is called during the initialization after all modules have been loaded but before ProcessWire has fully bootstrapped and started delivering content.
	//  Itâ€™s the right place to add hooks or events that occur before page rendering starts.

	public function init()
	{
		/** @var Wire $this */

		// make this module available in template files using $mu
		// eg $mu->twitter;
		$this->wire('mu', $this);

		// set a nonce we can use in script tags.
		$nonce = base64_encode(random_bytes(20));
		$this->mu_nonce = $nonce;

		// and add a hook to get the nonce easily.
		$this->addHookProperty("Page::nonce", $this, "hook_nonce");

		// add our page edit buttons.
		$this->addHookAfter('Page::render', $this, 'edit_buttons');

		// Add Bernhard's ajax hooks.
		$this->ajaxAddEndpoints();
	}

	public function ___execute()
	{
		// We don't show the manage settings unless you have
		// the millco-utils-manage permissions.
		// TODO - we don't want to show this page at all if you don't have permissions....
		// must work out how.
		if (!(wire('user')->hasPermission('millco-utils-manage'))) {
			return 'You require additional permissions to edit these settings.';
		}

		if ($this->input->post('submit')) {
			$this->mu_save_settings($this->input->post);
		}

		$admin_page_markup = '';

		$moduleConfig = $this->modules->getModuleConfigData('MillcoUtils');

		$admin_page_markup .= '<div class="uk-panel" style="margin:2rem 0; padding:2rem;background-color:#eee">';
		$admin_page_markup .= '<div><strong>Processwire Version : </strong>' .  wire('config')->versionName . '</div>';
		$admin_page_markup .= '<div><strong>PHP version : </strong>' . phpversion('tidy') . '</div>';
		if ($_SERVER['REMOTE_ADDR']) {
			$admin_page_markup .= '<div><strong>Server IP address : </strong>' . $_SERVER['REMOTE_ADDR'] . '</div>';
		}

		$panel_info = wire('files')->render(wire('config')->paths->siteModules . 'MillcoUtils/panel_info.php');
		$admin_page_markup .=$panel_info;



		$admin_page_markup .= '</div>';

		/** @var InputfieldForm $form */
		$form = $this->modules->get('InputfieldForm');
		// $form->action = './Mu_save_settings';

		/** @var InputfieldFieldset $fieldset */
		$fieldset = $this->modules->get('InputfieldFieldset');
		$fieldset->label = 'Edit Bar';
		$fieldset->description = 'Set the intial position of the edit toolbar.';
		$fieldset->notes = 'These should be CSS position values. eg. 4px for top and 0px for right will pin the bar to the right hand side of the screen.';
		$fieldset->collapsed = Inputfield::collapsedYes;

		$field = $this->modules->get('InputfieldText');
		$field->name = 'top';
		$field->value = $moduleConfig['top'];
		$field->columnWidth = 25;
		$fieldset->add($field);

		$field = $this->modules->get('InputfieldText');
		$field->name = 'right';
		$field->value = $moduleConfig['right'];
		$field->columnWidth = 25;
		$fieldset->add($field);

		$field = $this->modules->get('InputfieldText');
		$field->name = 'bottom';
		$field->value = $moduleConfig['bottom'];
		$field->columnWidth = 25;
		$fieldset->add($field);

		$field = $this->modules->get('InputfieldText');
		$field->name = 'left';
		$field->value = $moduleConfig['left'];
		$field->columnWidth = 25;
		$fieldset->add($field);

		$field = $this->modules->get('InputfieldTextArea');
		$field->label = 'Additional buttons';
		$field->name = 'extra_buttons';
		$field->description = 'Enter additional links to add to the bar. These should be in the format url,label,icon and then an optional role eg /admin/setup/mu/,Utils,settings,editor';
		
		// Get list of available icons from our
		// MillcoUtils/icons directory
		$icons_array=[];
		$icons_directory = wire('config')->paths->siteModules . 'MillcoUtils/icons/';
		foreach (new \DirectoryIterator($icons_directory) as $file) {
			if ($file->isFile()) {
				$icons_array[]=$file->getBasename('.svg');
			}
		}
		
		sort($icons_array);//I always think DirectoryIterator should be able to do this.

		$icons_list=implode(', ',$icons_array);

		$fieldset->notes = 'Current availabele icons: ' . $icons_list . ' - You can add new svg icons to the MillcoUtils/icons folder.';

		$field->value = $moduleConfig['extra_buttons'];
		$field->columnWidth = 100;
		$fieldset->add($field);

		$form->add($fieldset);

		/** @var InputfieldFieldset $fieldset */
		$fieldset = $this->modules->get('InputfieldFieldset');
		$fieldset->label = 'Social media';
		$fieldset->description = 'Enter your social media user names.';
		$fieldset->notes = '';
		$fieldset->collapsed = Inputfield::collapsedYes;

		$field = $this->modules->get('InputfieldText');
		$field->name = 'twitter';
		$field->value = $moduleConfig['twitter'];
		$field->columnWidth = 25;
		$fieldset->add($field);

		$field = $this->modules->get('InputfieldText');
		$field->name = 'youtube';
		$field->value = $moduleConfig['youtube'];
		$field->columnWidth = 25;
		$fieldset->add($field);

		$field = $this->modules->get('InputfieldText');
		$field->name = 'facebook';
		$field->value = $moduleConfig['facebook'];
		$field->columnWidth = 25;
		$fieldset->add($field);

		$field = $this->modules->get('InputfieldText');
		$field->name = 'instagram';
		$field->value = $moduleConfig['instagram'];
		$field->columnWidth = 25;
		$fieldset->add($field);

		$form->add($fieldset);

		$button = $this->modules->get('InputfieldSubmit');
		$button->value = 'Save';
		$button->icon = 'floppy-o';

		$form->add($button);


		$admin_page_markup .= $form->render();

		return $admin_page_markup;

	}

	//ready() method: This is called after ProcessWire is fully bootstrapped, and is about to start rendering a page. At this point, the entire API is available and ready for use. This method can be used when you depend on the current page being accessed, like changing or adding certain behaviors or settings based on the current page or user.
	public function ready()
	{
	}

	/**
	 * Update our module config settings with the submitted
	 * values.
	 * 
	 * @param Object $post_data
	 */
	public function mu_save_settings($post_data)
	{

		// Get the current config data as an array
		$mu_config_data = $this->modules->getConfig('MillcoUtils');

		// TODO sanitize all these better.
		$top = $post_data->top;
		$mu_config_data['top'] = $top;

		$right = $post_data->right;
		$mu_config_data['right'] = $right;

		$bottom = $post_data->bottom;
		$mu_config_data['bottom'] = $bottom;

		$left = $post_data->left;
		$mu_config_data['left'] = $left;

		$extra_buttons = $post_data->extra_buttons;
		$mu_config_data['extra_buttons'] = $extra_buttons;


		$twitter = $post_data->twitter;
		$mu_config_data['twitter'] = $twitter;

		$facebook = $post_data->facebook;
		$mu_config_data['facebook'] = $facebook;

		$youtube = $post_data->youtube;
		$mu_config_data['youtube'] = $youtube;

		$instagram = $post_data->instagram;
		$mu_config_data['instagram'] = $instagram;

		$this->message('Settings saved'); // TODO check we have actually updated something.

		$this->modules->saveConfig('MillcoUtils', $mu_config_data);

		// reload our utils page
		/** @var Wire $this */
		$this->session->redirect('./');
	}

	public function hook_nonce($event)
	{
		$event->return = $this->mu_nonce;
	}

	/**
	 * modify the return value of Page::render() to add our edit toolbar markup. 
	 * 
	 */

	public function edit_buttons($event)
	{

		// Bail out early if we don't have permission to do this.
		// TODO. Might be nice to set a which groups get the edit button (and
		// not the admin settings).

		if (!(wire('user')->hasPermission('millco-utils'))) {
			return;
		}

		// Get the current page
		$page = $event->object;


		if (!($page->template == 'admin')) {

			// Edit link to admin for howard.
			// which is in fact really useful.
			if (wire('user')->isLoggedin() && $page->editable()) {

				// $edit_butt_markup='<div class="mu_edit_bar">';

				// // TODO 
				// // Add different options for super users.
				// $edit_butt_markup.= "<a class='edit-link' href='$page->editUrl'>Edit</a>";

				// $edit_butt_markup.='</div>';

				$path = wire('config')->paths->siteModules . 'MillcoUtils/markup_edit_button.php';

				// $path='/site/modules/MillcoUtils/markup_edit_button.php';

				$edit_butt_markup = wire('files')->render($path);

				$updated = str_replace('</body', $edit_butt_markup . '</body', $event->return);

				$event->return = $updated;
			}
		}
	}


	/**
	 * 
	 * This are Bernhard's functions from RockFrontend to automatically add hooks for any
	 * php files in template/ajax which is a very handy idea for htmx.
	 * 
	 * https://github.com/baumrock/RockFrontend
	 * 
	 * Honestly I should probably just add RockFronted and access these but
	 * whilst we're still trying to keep this module slim I'm going to use them.
	 * 
	 */

	protected function ajaxAddEndpoints(): void
	{
		// scan for these extensions
		// earlier listed extensions have priority
		$extensions = ['latte', 'php'];

		// attach hook for every found endpoint
		$added = [];
		foreach ($extensions as $ext) {
			$endpoints = $this->wire->files->find(
				$this->wire->config->paths->templates . "api",
				['extensions' => [$ext]]
			);
			foreach ($endpoints as $endpoint) {
				$base = pathinfo($endpoint, PATHINFO_FILENAME);
				if (in_array($base, $added)) continue;
				$added[] = $base;
				$this->wire->addHook("/ajax/$base", function (HookEvent $event) use ($endpoint) {

					// Bernhard has a check in here for
					// ensuring requests are ajax, I think in quite a few cases
					// we won't want to do that so I'm just returning the public view.
					return $this->ajaxPublic($endpoint);

					// // make htmx endpoints only available via ajax
					// // superusers are allowed to access them directly (for debugging)
					// $sudo = $this->wire->user->isSuperuser();
					// $isHtmx = isset($_SERVER['HTTP_HX_REQUEST']) && $_SERVER['HTTP_HX_REQUEST'];
					// $ajax = $this->wire->config->ajax || $isHtmx;

					// if (!$ajax and $sudo) return $this->ajaxDebug($endpoint);
					// else return $this->ajaxPublic($endpoint);
				});
			}
		}
	}

	private function ajaxDebug($endpoint): string
	{
		// dont catch errors when debugging
		$raw = $this->ajaxResponse($endpoint);
		return $raw;

		// $response = Dumper::toHtml($raw);

		// // render html
		// $markup = $this->render(__DIR__ . "/stubs/ajax-debug.latte", [
		// 	'endpoint' => $endpoint,
		// 	'response' => $response,
		// 	'formatted' => $this->ajaxFormatted($raw, $endpoint),
		// ]);

		// return $markup;
	}

	private function ajaxFormatted($raw, $endpoint): string
	{
		$extension = pathinfo($endpoint, PATHINFO_EXTENSION);
		if ($extension === "latte") {
			$response = $this->render($endpoint);
		} else $response = $raw;

		// is response already a string?
		if (is_string($response)) {
			$exceptions = [
				self::ajax_noaccess => "No access",
				self::ajax_rendererror => "Error rendering endpoint - see logs for details.",
			];
			if (array_key_exists($response, $exceptions)) {
				throw new WireException($exceptions[$response]);
			}

			// no exception - return string
			return $response;
		}

		// array --> json
		if (is_array($response)) return json_encode($response, JSON_PRETTY_PRINT);

		// still no string, try to cast it to string
		try {
			$response = (string)$response;
		} catch (\Throwable $th) {
			throw new WireException("Invalid return type");
		}

		return $response;
	}

	private function ajaxPublic($endpoint): string
	{
		try {
			$raw = $this->ajaxResponse($endpoint);
			$response = $this->ajaxFormatted($raw, $endpoint);
			return $response;
		} catch (\Throwable $th) {
			/** @var Wire $this */
			$this->log($th->getMessage());
			return "Error in AJAX endpoint - error has been logged";
		}
	}

	private function ajaxResponse($endpoint)
	{
		/** @var Wire $this */
		if ($this->wire->user->isSuperuser()) {
			return $this->wire->files->render($endpoint);
		}
		try {
			return $this->wire->files->render($endpoint);
		} catch (\Throwable $th) {
			$this->log($th->getMessage());
			return self::ajax_rendererror;
		}
	}

}
