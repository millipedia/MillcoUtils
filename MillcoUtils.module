<?php

namespace ProcessWire;

use function PHPSTORM_META\map;

/**
 * MillcoUtils
 * 
 * Just a collection of things we like to have in a site.
 * stephen @ millipedia.com
 */


class MillcoUtils extends WireData implements Module, ConfigurableModule
{

	public $nonce = ''; // a page nonce we set for use in inline scripts etc
	public $mu_settings; // some sitewide settings.


	public static function getModuleInfo()
	{
		return [
			'title' => 'MillcoUtils',
			'summary' => 'Very simple config options we often use.',
			'version' => 103,
			'autoload' => true,
			'singular' => true,
			'permanent' => false,
			'permission' => '',
			'icon' => 'cogs',
			'requires' => [
				'PHP>=8.0.0',
				'ProcessWire>=3.0.16',
			],
			'installs' => [
				'ProcessMillcoUtils',
				'TextformatterMillcoUtils'
			]
		];
	}

	// Add config fields.
	function getModuleConfigInputfields(InputfieldWrapper $inputfields)
	{
		// at the moment we have our settings on separate page now
		// handled by ProcessMillcoUtils.... so maybe this doesn't
		// need to be a configurable module at all now.

		// Let's add the readme to the config page tho.

		$readme = $this->wire->files->render(__DIR__ . "/README.md");
		$inputfields->add([
			'type' => 'markup',
			'label' => 'Readme',
			'icon' => 'life-ring',
			'collapsed' => Inputfield::collapsedYesAjax,
			'value' => $this->wire->sanitizer->entitiesMarkdown($readme, true),
		]);

		return $inputfields;
	}

	static protected $defaults = array(
		'top' => '',
		'right' => '',
		'bottom' => '',
		'left' => '',
		'eb_vertical' => '0',
		'bluesky' => '',
		'youtube' => '',
		'facebook' => '',
		'instagram' => '',
		'extra_buttons' => '',
		'cabin' => '0',
		'cabin_custom' => '',
		'fathom' => '',
		'holding_page' => '',
		'analytics_in_dev' => '0',
		'analytics_public_dashboard' => '',
		'inline_image_path' => 'icons',
		'load_admin_tweaks' => '0',
		'load_admin_scripts' => '0'

	);

	public function get_defaults()
	{
		return self::$defaults;
	}

	public function __construct()
	{
		// populate defaults, which will get replaced with actual
		// configured values before the init/ready methods are called
		// Updating this array is done in ProcessMillcoUtils now.
		$this->setArray(static::$defaults);
	}


	// 	init() method: This is called during the initialization after all modules have been loaded but before ProcessWire has fully bootstrapped and started delivering content.
	//  It's the right place to add hooks or events that occur before page rendering starts.

	public function init()
	{
		/** @var MillcoUtils $this */

		// make this module available in template files using $mu
		$this->wire('mu', $this);

		// set a nonce we can use in script tags.
		$nonce = base64_encode(random_bytes(20));
		$this->nonce = $nonce;

		// and add a hook to get the nonce easily.
		$this->addHookProperty("Page::nonce", $this, "hook_nonce");

		// add our page edit buttons.
		$this->addHookAfter('Page::render', $this, 'edit_buttons');

		// add our analytics tag
		$this->addHookAfter('Page::render', $this, 'analytics_tags');

		// add our ajax endpoints.
		$this->ajaxAddEndpoints();

		$moduleConfig = $this->modules->getConfig('MillcoUtils');

		// Add admin tweak styles if the user has opted in.
		if (array_key_exists('load_admin_tweaks', $moduleConfig) && $moduleConfig['load_admin_tweaks']) {
			$this->config->styles->add($this->config->urls->MillcoUtils . "css/admin_tweaks.css");
		}

		// Add HTMX to admin if the user has opted in.
		// Cos we use HTMX in various modules I just want to be able to load it in one place.
		if (array_key_exists('load_admin_scripts', $moduleConfig) && $moduleConfig['load_admin_scripts']) {
			$this->config->scripts->add($this->config->urls->MillcoUtils . "lib/htmx/htmx.min.js");
		}
	}

	//ready() method: This is called after ProcessWire is fully bootstrapped, and is about to start rendering a page. At this point, the entire API is available and ready for use. This method can be used when you depend on the current page being accessed, like changing or adding certain behaviors or settings based on the current page or user.
	public function ready()
	{

		// This is where we check for a holding page.
		// This can't go in init because the page isn't loaded yet.

		if (wire('page')->template != 'admin') {		// we only want to do this on the frontend.

			$moduleConfig = $this->modules->getConfig('MillcoUtils');

			if (array_key_exists('holding_page', $moduleConfig) && $moduleConfig['holding_page'] != '') {

				$allow_access = false;
				$error_message = '';

				// are we logged in?
				if (wire('user')->isLoggedin() || wire('session')->loggedin) {
					$allow_access = true;
				} else {

					// check for submitted password 
					if (wire('input')->post->pass) {
						$pass = \strtolower(wire('input')->post->pass);
						if ($pass == $moduleConfig['holding_page']) {
							wire('session')->loggedin = 1;
							$allow_access = true;
						} else {
							wire('session')->login_error = 'Please check your Password';
							$error_message = 'Please check your Password';
						}
					}
				}

				if (!$allow_access) { // don't allow access to the site and show the holding page.

					// Do we have a file holding_page.php in the templates folder?
					if (file_exists(wire('config')->paths->templates . 'holding_page.php')) {
						$holding_page_file = wire('config')->paths->templates . 'holding_page.php';
					} else { // Use our module version.
						$holding_page_file = wire('config')->paths->siteModules . 'MillcoUtils/markup/holding_page.php';
					}

					include($holding_page_file);
					exit(0);
				}
			}
		}
	}

	/**
	 * Attach the nonce to the return value of Page::nonce.
	 */
	public function hook_nonce($event)
	{
		$event->return = $this->nonce;
	}

	/**
	 * Add hooks for ajax endpoints in the templates/ajax folder.
	 * This is a much simpler version of the RockFrontend ajaxAddEndpoints method.
	 */
	protected function ajaxAddEndpoints(): void
	{

		$ajax_folder = wire('config')->paths->templates . 'ajax';

		// Bail out early if the folder doesn't exist.
		if (!$this->wire->files->exists($ajax_folder)) {
			return;
		}

		// Loop through all php files in the ajax folder
		$ext = 'php';
		$opt = ['extensions' => [$ext]];
		$endpoints = $this->wire->files->find($ajax_folder, $opt);
		foreach ($endpoints as $file) {

			// get url after folder
			// we can't use basename because we support nested folders/endpoints
			$ajax_url = substr($file, strlen($ajax_folder), - (strlen($ext) + 1));

			// all our ajax endpoints begin with /ajax/ cos hey, that's the way I like it.
			$ajax_url = '/ajax' . $ajax_url;

			wire()->addHook($ajax_url, function (HookEvent $event) use ($file) {

				// All we do is include the file and let it do its own thing,
				// so you'll need to handle the response in your own file.
				$response = wire('files')->render($file);
				$event->return = $response;
			});
		}
	}


	/**
	 * modify the return value of Page::render() to add our edit toolbar markup. 
	 * 
	 */

	public function edit_buttons($event)
	{

		// Bail out early if we don't have permission to do this.
		// TODO. Might be nice to set a which groups get the edit button (and
		// not the admin settings).

		if (!(wire('user')->hasPermission('millco-utils'))) {
			return;
		}

		// Get the current page
		$page = $event->object;

		if (!($page->template == 'admin')) {

			// Edit link to admin for howard.
			// which is in fact really useful.
			if (wire('user')->isLoggedin() && $page->editable()) {

				$path = wire('config')->paths->siteModules . 'MillcoUtils/markup/markup_edit_button.php';

				$edit_butt_markup = wire('files')->render($path);

				$updated = str_replace('</body', $edit_butt_markup . '</body', $event->return);

				$event->return = $updated;
			}
		}
	}


	/**
	 * Add analytics tags
	 */

	public function analytics_tags($event)
	{

		$page = $event->object;
		if (!($page->template == 'admin') && !($page->template == 'api')) {

			// if we're in dev mode and don't have analytics_in_dev seleted
			// then just bail out.
			if (wire('config')->debug && !($this->analytics_in_dev)) {
				return;
			}

			$tags_to_add = '';

			// Have we checked the Add Cabin checkbox?
			if ($this->cabin) {

				// If we have a custom domain provide then use that
				// instead of the default domain.

				$cabin_domain = 'scripts.withcabin.com';

				if (!empty($this->cabin_custom)) {
					$cabin_domain = $this->cabin_custom;
				}

				$tags_to_add .= ' <script async defer src="https://' . $cabin_domain . '/hello.js" nonce="' . $this->nonce . '"></script>' . PHP_EOL;
			}

			// Add a tag for Fathom analytics (https://usefathom.com)
			// if we've entered a site code.
			$fathom = $this->fathom;

			if (!empty($fathom)) {

				$tags_to_add .= ' <script src="https://cdn.usefathom.com/script.js" data-site="' . $fathom . '" nonce="' . $this->nonce . '=" defer></script>' . PHP_EOL;
			}

			// If we have something to add then inject
			// it before the closing </head> tag.
			if ($tags_to_add !== '') {
				// Check for the closing </head> tag, or <body for pages without head tags.
				$headPos = strpos($event->return, '</head>');
				if ($headPos !== false) {
					$event->return = substr_replace($event->return, $tags_to_add, $headPos, 0);
				} else {
					// should probably be checking if body tag exists instead.
					$bodyPos = strpos($event->return, '<body');
					if ($bodyPos !== false) {
						$event->return = substr_replace($event->return, '<head>' . $tags_to_add . '</head>', $bodyPos, 0);
					}
				}
			}
		}
	}


	/**
	 * Add open graph tags
	 * 
	 * @param Array $options
	 * @return String
	 */

	public function open_graph_tags($options = [])
	{

		$path = wire('config')->paths->siteModules . 'MillcoUtils/markup/open_graph_tags.php';

		$open_graph_markup = wire('files')->render($path, ['options' => $options]);

		return $open_graph_markup;
	}

	/**
	 * load an icon inline from a file
	 * @param String $filename
	 * 
	 * Takes the name of an svg file (without extension) and reads in the data 
	 * from the file if it exists in /site/assets/images/
	 * You can set a subfolder in the utils admin settings to change the path.
	 * tip: using currentColor in your SVG is very useful.
	 */

	public function file_icon($filename)
	{

		// We now have a config value for the base path relative to images
		$inline_image_path = $this->inline_image_path;

		$inline_image_path = str_replace('..', '', $inline_image_path); // let's not allow iterating up the path.

		// sort out directory separators in case our user has added them;
		if ($inline_image_path !== '') {
			$inline_image_path = rtrim($inline_image_path, "/");
			$inline_image_path = ltrim($inline_image_path, "/");
			$inline_image_path .= '/';
		}

		$path = wire('config')->paths->assets . 'images/' . $inline_image_path;

		return $this->get_icon_markup($filename, $path);
	}

	/**
	 * load an icon inline from our module icons folder
	 * @param String $filename
	 * 
	 */

	public function icon($filename)
	{

		$path = wire('config')->paths->siteModules . 'MillcoUtils/icons/';
		return $this->get_icon_markup($filename, $path);
	}

	/**
	 * get_icon_markup
	 * Given a filename and a path, grab the svg and return it as a string.
	 * 
	 * @param String $filenamepath
	 * @return String
	 */

	private function get_icon_markup($filename, $path)
	{

		// In case we've passed the filename with .svg on the end then remove it.
		// I guess it could be the case we have an oddly named file but not as often
		// as I forget and leave the extension on.
		$suffix = substr($filename, -4);
		if ($suffix == '.svg') {
			$filename = substr($filename, 0, -4);
		}

		$filename = $path . $filename . '.svg';

		$icon_markup = '';

		if (file_exists($filename) && $icon = file_get_contents($filename)) {
			$icon_markup = $icon;
			return $icon_markup;
		} else {

			// Dump to Tracy if it's installed.
			if (function_exists('bd')) {

				bd('missing icon: ' . $filename);
			}

			return '?';
		}
	}

	/**
	 * Return the markup for our modal dialog widget.
	 * 
	 * @return String
	 */

	public function modialog()
	{

		// Bail out early if we don't have permission to do this.
		if (!(wire('user')->hasPermission('millco-utils'))) {
			return;
		}

		$path = wire('config')->paths->siteModules . 'MillcoUtils/markup/modialog.php';

		$modialog_markup = wire('files')->render($path, ['mu' => $this]);

		return $modialog_markup;
	}


	/**
	 * Source set
	 * 
	 * Takes a Pageimage object and does some basic source setting.
	 * 
	 * @param Pageimage $image
	 * @param Int widht
	 * @param Int height
	 * @param Array options
	 */


	function source_set($image, $width = 1440, $height = 'auto', $options = array())
	{

		$image_markup = '';
		$caption = '';
		$alt = '';
		$classes = '';

		$quality = 72;
		$upscale = false;
		$webp_quality = 62;


		if (isset($options['quality']) && $options['quality'] == 'high') {
			$quality = 80;
			$webp_quality = 80;
		}

		if (isset($options['upscale']) && $options['upscale']) {
			$upscale = true;
		}

		if (isset($options['class'])) {
			$classes .= $options['class'];
		} else {
			$classes = ' image_fluid';
		}

		if ($image) {

			// Resize our image.
			$thumb = $image->size($width, $height, [
				'quality' => $quality,
				'webpQuality' => $webp_quality,
				'upscaling' => $upscale,
				'sharpening' => 'medium'
			]);


			// Caption and alt text are pulled from custom fields.
			// the name of which has varied over the years hence we check for a few different
			// options.
			if ($image->img_alt) {
				$alt = $image->img_alt;
			} elseif ($image->image_alt) {
				$alt = $image->image_alt;
			} elseif ($image->text_field) {
				$alt = $image->text_field;
			} elseif ($image->description) {
			} elseif ($image->image_alt) {
				$alt = $image->image_alt;
			} elseif ($image->description) {
				$alt = $image->description;
			}

			// If we have a no_caption option then don't add a caption.
			if (isset($options['no_caption']) && $options['no_caption'] == 1) {
				$caption = '';
			} else {
				// again, these are all fields I've used for the caption over the years.
				if ($image->img_caption) {
					$caption = $image->img_caption;
				} elseif ($image->image_caption) {
					$caption = $image->image_caption;
				} elseif ($image->caption) {
					$caption = $image->caption;
				} elseif ($image->sub_content) {
					$caption = $image->sub_content;
				}

				// We can't have paragraph tags in the caption.
				$caption = mb_ereg_replace('^<p>|</p>$', '', $caption);
			}

			// default to lazy loading.
			if (isset($options['not_lazy']) && $options['not_lazy'] == 1) {
				$lazy = '';
			} else {
				$lazy = ' loading=lazy';
			}

			$image_markup .= '<picture>';
			$image_markup .= '<source srcset="' . $thumb->webp->url . '" type="image/webp">';

			// if our picture is wider than 480px let do a version for phones  etc....
			// I know it's not very exact but it's better than nothing.
			$smol_width = 480;

			if ($thumb->width > $smol_width) {

				$pic_ratio = $thumb->width / $thumb->height;

				$smol_height = $smol_width / $pic_ratio;

				$smol_pic = $image->size($smol_width, $smol_height, [
					'quality' => $quality,
					'webpQuality' => $webp_quality,
					'upscaling' => false,
					'sharpening' => 'medium'
				]);

				$image_markup .= '<source media="(max-width: 480px)" srcset="' . $smol_pic->webp->url . '" type="image/webp">';
			}

			$image_tag_markup = '<img class="' . $classes . '" src="' . $thumb->url . '" alt="' . $alt . '" width="' . $thumb->width . '" height="' . $thumb->height . '" ' . $lazy . '>';


			// just in case we want to return just the image tag without the picture tag.
			// ... not really a source set then, but hey, I've just needed to do it.
			if (isset($options['image_tag_only']) && $options['image_tag_only']) {
				return $image_tag_markup;
			} else {
				$image_markup .= $image_tag_markup;
			}


			$image_markup .= '</picture>';

			// let's only wrap in a figure now if we have a caption.
			if ($caption !== '') {
				$image_markup = '<figure>' . $image_markup;
				$image_markup .= '<figcaption>' . htmlspecialchars_decode($caption) . '</figcaption>';
				$image_markup .= '</figure>';
			}
		}

		return $image_markup;
	}

	/**
	 * Generate a password
	 * 
	 * @param Int $required_entries
	 * @param Array $options
	 * @return Array
	 */

	public function reasonable_password($required_entries = 1, $options = array())
	{

		if(isset($options['wordlist']) && $options['wordlist'] == 'long'){
			$wordlist = 'eff_large_wordlist.txt';
		}else{
			$wordlist = 'eff_short_wordlist.txt';
		}

		if(isset($options['separator'])){
			$separator = $options['separator'];
		}else{
			$separator = '-';
		}

		$words = file(wire('config')->paths->siteModules . 'MillcoUtils/lib/diceware/' . $wordlist, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);

		$no_of_words = count($words);

		// If we have a sensible length option then use that, otherwise default to 5.
		if(isset($options['length']) && $options['length'] > 2 && $options['length'] < 20){
			$no_of_words_in_passphrase = $options['length'];
		}else{
			$no_of_words_in_passphrase = 5;
		}

		$password_list = array();

		for ($i = 0; $i < $required_entries; $i++) {

			$pass = array();
			$tick = 0;

			// Pick some words and add them to the array.
			// Since you ask, I decided deliberately not check for duplicates here.
			while ($tick < $no_of_words_in_passphrase) {
				$index = mt_rand(0, $no_of_words);
				$pass[] = trim($words[$index]);
				$tick++;
			}

			$passphrase = implode($separator, $pass);

			// let's add a number (but not zero)
			$passphrase .= $separator . rand(2, 9);

			//  and a capital letter (but not O or I)
			$cromulent_letters = "ABCDEFGHJKLMNPQRSTUVWXYZ";
			$string_length = strlen($cromulent_letters);
			$string_index = mt_rand(0, $string_length - 1);
			$passphrase .=  $cromulent_letters[$string_index];

			// I can't believe this is ever practically going to happen but let's check we don't have this already...
			if (in_array($passphrase, $password_list)) {
				$i--;
			} else {
				// add it to the list.
				$password_list[] = $passphrase;
			}
		}

		// If we've only asked for one password then return just that.
		// Otherwise return the array of passwords.
		if ($required_entries == 1) {
			return $password_list[0];
		} else {
			return $password_list;
		}
	}
}
